package network.udpn.web3j;


import io.reactivex.Flowable;
import java.io.IOException;
import java.math.BigInteger;
import java.net.InetSocketAddress;
import java.net.Proxy;
import java.net.ProxySelector;
import java.net.SocketAddress;
import java.net.URI;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.TimeUnit;
import network.udpn.web3j.A.StoreEventResponse;
import okhttp3.OkHttpClient;
import org.junit.Test;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.web.client.RestTemplate;
import org.web3j.abi.FunctionEncoder;
import org.web3j.abi.TypeReference;
import org.web3j.abi.datatypes.Type;
import org.web3j.abi.datatypes.generated.Uint256;
import org.web3j.crypto.Credentials;
import org.web3j.crypto.RawTransaction;
import org.web3j.crypto.TransactionEncoder;
import org.web3j.protocol.Web3j;
import org.web3j.protocol.core.DefaultBlockParameterName;
import org.web3j.protocol.core.DefaultBlockParameterNumber;
import org.web3j.protocol.core.methods.request.Transaction;
import org.web3j.protocol.core.methods.response.EthCall;
import org.web3j.protocol.core.methods.response.EthGetTransactionCount;
import org.web3j.protocol.core.methods.response.EthGetTransactionReceipt;
import org.web3j.protocol.core.methods.response.EthSendTransaction;
import org.web3j.protocol.core.methods.response.TransactionReceipt;
import org.web3j.protocol.http.HttpService;
import org.web3j.protocol.websocket.WebSocketService;
import org.web3j.tx.RawTransactionManager;
import org.web3j.tx.gas.StaticGasProvider;
import org.web3j.utils.Numeric;

public class BNEntWeb3jTest {

  /**
   * Contract introduction in the test class:
   *   1,The contract has two methods:
   *     (1)store: parameter is a BigInteger. Stores a value on the blockchain.
   *               Later executions will overwrite earlier ones.
   *     (2)retrieve: no parameter. Retrieves the value stored by the store method from the blockchain.
   *   2,It is possible to obtain the events generated by the execution of the store method.
   */


  /**
   * Business flow method introduction in the test class:
   * <p>
   * 1,Call BN's project save interface to obtain the projectCode. Method name: projectSaveTest
   * 2,Call BN's contract save interface with the projectCode obtained in the first step to obtain the scCode parameter. Method name: contractSaveTest
   * 3,Call BN's contract submission interface with the scCode obtained in the second step. Method name: submitContractTest
   * 4,Deploy the contract and obtain the contract address. Method name: deployUseProxy or deployUseWeb3j
   * 5,Set the contract scCode for the contract address. Method name: setContractCodeTest
   * 6,Use the contract address to call the store method of the contract with signed data. Method name: invokeUseProxy or invokeUseWeb3j
   * 7,Use the contract address to call the retrieve method of the contract with encrypted data. Method name: callUseProxy or callUseWeb3j
   * 8,Obtain the events generated after calling the store method. Method name: getStoreEvent
   * 9,Query the contract address based on the transaction hash. Method name: getContractAddressByHash
   * 10,Query the contract address based on the transaction hash. Method name: getResultByHash
   * 11,Obtain the signed data for requesting the test contract's retrieve method. Method name: getCallSignatureStrTest
   * 12,Obtain the signed data for deploying the test contract. Method name: getDeploySignatureStrTest
   * 13,Obtain the signed data for requesting the test contract's store method. Method name: getStoreSignatureStrTest
   */

  // Token required to be carried for requesting the interface.
  private String apiToken = "eyJ0eXAiOiJKV1QiLCJ0eXBlIjoiT1BFTi1BUEktSldUIiwiYWxnIjoiSFMyNTYifQ.eyJhcHBUb2tlbiI6IntcImFwcGxpY2F0aW9uQ29kZVwiOlwiQUNfMTU5ZmExZDY0NzJhNDYyM2EyNDM4OWEwOTBjOTNmODZcIixcImJuQ29kZVwiOlwiQk4wMDAwMDE3XCIsXCJibkRpZFwiOlwiZGlkOnVkcG46Z3h1N05EdzFGVHFQUVRpb3FNejhEcHk3TkNwXCIsXCJjbGllbnRJZFwiOjEsXCJleHBpcmF0aW9uRGF0ZVwiOjE3MTM0MTkzMzAwMDAsXCJ1dWlkXCI6XCI1NTc4ZGUxZjIxODA0YmQyOTlhY2QwNmRmYmYzNDMwMlwifSIsImV4cCI6MTcxMzQxOTMzMH0.WaH-SebcQYdpihQdUofTlKcFE3DjZFoF3C-n7XzGXK0\n";

  // Service address.
  // LOCAL
  //    private String url = "127.0.0.1:8082";
  // QA
  //    private String url = "69.230.239.221:8082";
  // quasi-production
  private String url = "18.167.0.72:30082";
  // production
  //    private String url = "6.163.247.242:31582";

  // Interface for building web3j in BN.
  private String web3jUrl = "http://" + url + "/restapi/transaction";

  // BN's WebSocket address.
  private String webSocketUrl = "ws://" + url + "/ws/transaction/" + apiToken;

  // Interface for saving contract in BN.
  private String contractSaveUrl = "http://" + url + "/v1/udpn/processing/contract/manage/save";

  // Interface for saving project in BN.
  private String projectSaveUrl =
      "http://" + url + "/v1/udpn/processing/contract/package/manage/creat/save";

  // Interface for setCode in BN.
  private String setCodeUrl =
      "http://" + url + "/v1/udpn/processing/contract/manage/set/contract/code";

  // Interface for submitting contract in BN.
  private String submitUrl = "http://" + url + "/v1/udpn/processing/contract/manage/submit";


  // Account private key.
  private String accountPrivateKey = "6587d4293d6474c45d7f4d163f49997c08fcafc2cd5abe011ba2cfb8511e9f5b";

  // Account address.
  private String accountAddr = "0xce552f976c89e3d3310e37789d0c7e1afda85837";

  // Contract address. Note: This parameter should use the address output by executing the deploy contract method.
  private String contractAddress = "0x19fbc73984bb1f221a1159795f261a637684b9f0";

  // gas price
  private BigInteger gasPrice = BigInteger.ZERO;

  // Loop count used for web3j underlying implementation when retrieving transaction results based on hash.
  private int attempts = 50;

  // Sleep time (in milliseconds) used for web3j underlying implementation when retrieving transaction results based on hash.
  private int sleepDuration = 1000;

  // Building a Web3j object using the transaction URL provided by BN.
  HttpService httpService = new HttpService(web3jUrl);


  // Creating a WebSocketService using the websocket address provided by BN.
  WebSocketService ws = new WebSocketService(webSocketUrl, false);

  // Creating Credentials using the account private key, which will be used when making calls to web3j.
  Credentials credentials = Credentials.create(accountPrivateKey);


  /**
   * method description Project Save Interface
   *
   * @param
   * @return void
   * @date 2023/4/10
   */
  @Test
  public void projectSaveTest() {

    RestTemplate restTemplate = new RestTemplate();

    // Assembly parameters: project name, description
    Map<String, Object> params = new HashMap<>();

    params.put("contractPackageName", "YourTestProjectName");
    params.put("description", "Your test desc");

    HttpHeaders header = new HttpHeaders();
    header.set("Accept-Charset", "UTF-8");
    header.set("Content-Type", "application/json");
    header.set("apiToken", apiToken);
    HttpEntity<Map> httpEntity = new HttpEntity<>(params, header);

    // Call the contract saving interface of BN
    Map result = restTemplate.postForObject(projectSaveUrl, httpEntity, Map.class);

    Integer code = (Integer) result.get("code");
    if (code == 0) {
      Map data = (Map) result.get("data");
      String projectCode = data.get("contractPackageCode").toString();
      System.out.println(
          "<<<<<<<<<<<Output<<<<<<<The project is successfully saved and the projectCode is output（projectCode will be used in the method contractSaveTest, please keep）：projectCode="
              + projectCode);
    } else {
      String message = result.get("message").toString();
      System.out
          .println("<<<<<<<<<<<Output<<<<<<<Project saving failed due to:" + code + "=" + message);
    }

  }


  /**
   * method description Contract save interface. parameter： Contract name: String type Compiler
   * version: String type Contract source code file: String type (the result after converting zip to
   * base64) result： Return a deployCode that uniquely identifies this record and is used to deploy
   * the contract
   *
   * @param
   * @return void
   * @date 2023/4/3
   */
  @Test
  public void contractSaveTest() {

    RestTemplate restTemplate = new RestTemplate();

    // Assembly parameters: contract name, compiler version, base64 string converted from contract source code zip file, contract description, project code, contract version
    Map<String, Object> params = new HashMap<>();

    params.put("scName", "YourTestScName");
    params.put("compilerVersion", "0.8.19");
    params.put("contractPackageBase64",
        "UEsDBBQACAgIAG6Uk1YAAAAAAAAAAAAAAAAJAAAAdGVzdDEuemlwC/BmZuFiAAHDzP4wBiTABsQlqcUlhvoBQDUiQB4HQw5QTV7uEmZDRgYGbyYGBn64GjCpV5yfUzrRP/uwAc/R94017HOv2U+wuHsj4nbpGwOJZrlTVTfX7ujbJSVkfaPIS/Lvu+7XS87yXfXc813l7wbJ5q+v/lpHejWeSvo0c7HSzskZaR82RqnxZ4q5F4ZI/gsu2rBrws4lynv0Nn2xnOvzUNV7eabZd0kzueOCPQ97VUQ5si+dFWDTPP5LR+FOo6ORUHbLLHE+R60Hvtkq98Vyoyy8d80xde4s1Np46ESXQurCjTrHV104ftbxUl3zFvfk4E11U45OvNDFI37lbvv9th5fqe2a6qJ37e0ai56KnZ1563Tjnev2V7jj+9fxht75cGl9pvOSg79m6h102lzsNeGK1ozD934KhuRFezz8uGCtAyv3/TPNNbs6f7Q+6ck6H697efpXPrbElw/EIr5LHuYO0P3IkNjbyld55TDPva+80ecuywd4MzLJM+CKAxUoSwBKQ0Kbi0EBzGNkkGD49FW8IiL/JmP60z01kUA6ZB+EhpiLK95g5oLMUcGMRWQLchMf7gRZ0JK3F2wwzKIAb1ZQGmFgAsKdQLqJEcQDAFBLBwg7gQel0gEAAFECAABQSwECFAAUAAgICABulJNWO4EHpdIBAABRAgAACQAAAAAAAAAAAAAAAAAAAAAAdGVzdDEuemlwUEsFBgAAAAABAAEANwAAAAkCAAAAAA==");
    params.put("scDescribe", "Your test desc");
    // Obtained from test method: projectSaveTest
    params.put("contractPackageCode", "Prof364c42b88b54fb7a1bfb106d0cbcfef");
    params.put("scVersion", "1.1.02");
    params.put("compileEvmVersion", "paris");
    params.put("inputFilePath", "/test1/test1.sol");

    HttpHeaders header = new HttpHeaders();
    header.set("Accept-Charset", "UTF-8");
    header.set("Content-Type", "application/json");
    header.set("apiToken", apiToken);
    HttpEntity<Map> httpEntity = new HttpEntity<>(params, header);

    // Call the contract saving interface of BN
    Map result = restTemplate.postForObject(contractSaveUrl, httpEntity, Map.class);

    Integer code = (Integer) result.get("code");
    if (code == 0) {
      Map data = (Map) result.get("data");
      String scCode = data.get("scCode").toString();
      System.out.println(
          "<<<<<<<<<<<Output<<<<<<<The contract is successfully saved and the scCode is output（scCode is used in the method setContractCodeTest, please keep）：scCode="
              + scCode);

    } else {
      String message = result.get("message").toString();
      System.out.println(
          "<<<<<<<<<<<Output<<<<<<<Failed to save the contract due to:" + code + "=" + message);
    }

  }


  /**
   * method description  Contract submission interface parameter: scCodes, (obtained in
   * contractSaveTest)
   *
   * @param
   * @return void
   * @date 2023/4/19
   */
  @Test
  public void submitContractTest() {
    RestTemplate restTemplate = new RestTemplate();

    // Assembly parameters:scCodes
    List<String> scCodes = new ArrayList<>();
    // scCode is obtained from the test method: contractSaveTest
    scCodes.add("c5bb99ca32e64ea0af51f0e24923fa1a");

    Map<String, Object> params = new HashMap<>();
    params.put("scCodes", scCodes);

    HttpHeaders header = new HttpHeaders();
    header.set("Accept-Charset", "UTF-8");
    header.set("Content-Type", "application/json");
    header.set("apiToken", apiToken);
    HttpEntity<Map> httpEntity = new HttpEntity<>(params, header);

    // Call the contract saving interface of BN
    Map result = restTemplate.postForObject(submitUrl, httpEntity, Map.class);

    Integer code = (Integer) result.get("code");
    if (code == 0) {
      Map data = (Map) result.get("data");
      System.out.println("<<<<<<<<<<<Output<<<<<<<Contract submitted successfully");

    } else {
      String message = result.get("message").toString();
      System.out.println(
          "<<<<<<<<<<<Output<<<<<<<Contract submission failed due to:" + code + "=" + message);
    }
  }


  /**
   * method description Deployment contract: 1，deployUseProxy：Deploy the contract and use the proxy
   * class generated by abi and bin. Note: The parameter "deployCode" in the method is output in the
   * save interface. It cannot be reused. If the correct result has been returned, please call the
   * save interface again and output the deployCode. Result: output the contract address.
   * 2，deployUseWeb3j：To deploy the contract, use the method provided by web3j. Note: The parameter
   * "deployCode" is as above. Result: output transaction hash. Please use the method
   * "getContractAddressByHash" to get the contract address. Replace the value of the parameter
   * transactionHash with the output transaction hash. The above two methods will output the
   * contract address, please assign the contract address to be used to the parameter private String
   * contractAddress="".
   *
   * @param
   * @return void
   * @date 2023/4/3
   */
  @Test
  public void deployUseProxy() throws Exception {

    httpService.addHeader("apiToken", apiToken);

    Web3j web3jHttp = Web3j.build(httpService);

    // gasPrice is 0, gasLimit is obtained from the chain and multiplied by 10
    // Call the deploy method of the proxy class
    A send = A.deploy(web3jHttp, credentials,
        new StaticGasProvider(BigInteger.ZERO, testEstimateGas())).send();

    String contractAddress = send.getContractAddress();
    // Please configure the output contract address to private String contractAddress
    System.out.println(
        "<<<<<<<<<<<Output<<<<<<<Please configure the contract address to private String contractAddress");
    System.out.println(
        "<<<<<<<<<<<Output<<<<<<<Deploy the contract successfully and output the contract address（The contract address is used in the method setContractCodeTest, please keep it）：Contract address="
            + contractAddress);
  }


  /**
   * method description Deployment contract: 1，deployUseProxy：Deploy the contract and use the proxy
   * class generated by abi and bin. Note: The parameter "deployCode" in the method is output in the
   * save interface. It cannot be reused. If the correct result has been returned, please call the
   * save interface again and output the deployCode. Result: output the contract address.
   * 2，deployUseWeb3j：To deploy the contract, use the method provided by web3j. Note: The parameter
   * "deployCode" is as above. Result: output transaction hash. Please use the method
   * "getContractAddressByHash" to get the contract address. Replace the value of the parameter
   * transactionHash with the output transaction hash. The above two methods will output the
   * contract address, please assign the contract address to be used to the parameter private String
   * contractAddress="".
   *
   * @param
   * @return void
   * @date 2023/4/3
   */
  @Test
  public void deployUseWeb3j() throws Exception {

    // Set up the proxy configuration
    String proxyHost = "10.0.33.79"; // replace with your proxy host
    int proxyPort = 4545; // replace with your proxy port
    Proxy proxy = new Proxy(Proxy.Type.SOCKS, new InetSocketAddress(proxyHost, proxyPort));

    // Set up the ProxySelector with the proxy configuration
    ProxySelector proxySelector = new ProxySelector() {
      @Override
      public List<Proxy> select(URI uri) {
        return Collections.singletonList(proxy);
      }

      @Override
      public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {
        throw new UnsupportedOperationException("Proxy connection failed", ioe);
      }
    };

    OkHttpClient httpClient = new OkHttpClient.Builder()
        .connectTimeout(1000, TimeUnit.SECONDS)
        .readTimeout(1000, TimeUnit.SECONDS)
        .proxySelector(proxySelector)
        .build();

    // Building a Web3j object using the transaction URL provided by BN.
    HttpService httpServiceTest = new HttpService(web3jUrl, httpClient);

    httpServiceTest.addHeader("apiToken", apiToken);

    Web3j web3jHttp = Web3j.build(httpServiceTest);
    // Obtain deployment contract, signature data
    String deploySignatureStr = getDeploySignatureStr();

    // Call the SendRawTransaction method to deploy the contract
    EthSendTransaction sendResult = web3jHttp.ethSendRawTransaction(deploySignatureStr).send();

    // Get transaction hash
    String transactionHash = sendResult.getTransactionHash();
    // After obtaining the transaction hash, use the getContractAddressByHash method to query the contract address
    // Please configure the output contract address to private String contractAddress
    System.out.println(
        "<<<<<<<<<<<Output<<<<<<<The deployed contract successfully outputs the transaction hash: transaction hash="
            + transactionHash);
    System.out.println(
        "<<<<<<<<<<<Output<<<<<<<After obtaining the transaction hash, use the getContractAddressByHash method to query the contract address");
  }


  /**
   * method description Associate contract address with scCode
   *
   * @param
   * @return void
   * @date 2023/4/11
   */
  @Test
  public void setContractCodeTest() {
    RestTemplate restTemplate = new RestTemplate();

    Map<String, Object> params = new HashMap<>();
    // The output result of calling the deployUseProxy or deployUseWeb3j method
    params.put("contractAddress", "0xf62fc57d95f500f9905bd0e6925ca0f15e3afad8");
    // Call the contractSaveTest method to output the result
    params.put("contractCode", "ddddddd");

    HttpHeaders header = new HttpHeaders();
    header.set("Accept-Charset", "UTF-8");
    header.set("Content-Type", "application/json");
    header.set("apiToken", apiToken);
    HttpEntity<Map> httpEntity = new HttpEntity<>(params, header);

    // Call the contract saving interface of BN
    Map result = restTemplate.postForObject(setCodeUrl, httpEntity, Map.class);

    if ((Integer) result.get("code") != 0) {
      String message = (String) result.get("message");
      Integer code = (Integer) result.get("code");
      System.out.println(
          "<<<<<<<<<<<Output<<<<<<<set contract code fail，code=" + code + ",reason：" + message);
    } else {
      Map data = (Map) result.get("data");
      Boolean setContractStatus = (Boolean) data.get("setContractStatus");
      System.out.println(
          "<<<<<<<<<<<Output<<<<<<<set contract code status（If an error is reported, please wait a while and try again or contact the developer），result="
              + setContractStatus);
    }
  }


  /**
   * method description Call the store method of the contract. 1，invokeUseProxy：Use the proxy class
   * generated by abi and bin to call the store method of the contract. Remarks: The storeNum
   * parameter is the value stored on the chain. Can be changed to any BigInteger value. Result:
   * output transaction hash, and get method events synchronously 2，invokeUseWeb3j：Use web3j to call
   * the store method of the contract. Note: The storeNum parameter is as above. Result: output the
   * transaction hash, you can use the method "getResultByHash" to get the transaction result.
   *
   * @param
   * @return void
   * @date 2023/4/1
   */
  @Test
  public void invokeUseProxy() throws Exception {

    httpService.addHeader("apiToken", apiToken);

    Web3j web3jHttp = Web3j.build(httpService);

    // gasPrice is 0, gasLimit is obtained from the chain and multiplied by 10
    StaticGasProvider staticGasProvider = new StaticGasProvider(gasPrice, testEstimateGas());

    // Initialize the proxy class of the contract
    A contractA = A.load(
        contractAddress,
        web3jHttp,
        new RawTransactionManager(web3jHttp, credentials, attempts, sleepDuration),
        staticGasProvider
    );

    // the value to store on-chain
    BigInteger storeNum = new BigInteger("125");

    // Call the store method of the proxy class
    TransactionReceipt storeResult = contractA.store(storeNum).send();

    if (storeResult.isStatusOK()) {
      System.out.println(
          "<<<<<<<<<<<Output<<<<<<<The Store method is called successfully, hash=" + storeResult
              .getTransactionHash());

      List<StoreEventResponse> storeEvents = contractA.getStoreEvents(storeResult);
      if (storeEvents.size() != 0) {
        StoreEventResponse storeEventResponse = storeEvents.get(0);
        System.out.println(
            "<<<<<<<<<<<Output<<<<<<<Synchronously get the event of calling the Store method successfully, sender="
                + storeEventResponse.sender + "，storeNum=" + storeEventResponse.num);
      }

    }


  }


  /**
   * method description Call the store method of the contract. 1，invokeUseProxy：Use the proxy class
   * generated by abi and bin to call the store method of the contract. Remarks: The storeNum
   * parameter is the value stored on the chain. Can be changed to any BigInteger value. Result:
   * output transaction hash, and get method events synchronously 2，invokeUseWeb3j：Use web3j to call
   * the store method of the contract. Note: The storeNum parameter is as above. Result: output the
   * transaction hash, you can use the method "getResultByHash" to get the transaction result.
   *
   * @param
   * @return void
   * @date 2023/4/1
   */
  @Test
  public void invokeUseWeb3j() throws IOException {

    httpService.addHeader("apiToken", apiToken);

    Web3j web3jHttp = Web3j.build(httpService);
    BigInteger storeNum = new BigInteger("202304192222222");

    // Get the signed data after calling the store method
    String storeSignatureData = getStoreSignatureStr(storeNum);

    EthSendTransaction sendResult = web3jHttp.ethSendRawTransaction(storeSignatureData).send();

    if (null != sendResult.getTransactionHash() && !"".equals(sendResult.getTransactionHash())) {
      System.out.println(
          "<<<<<<<<<<<Output<<<<<<<The Store method is called successfully, hash=" + sendResult
              .getTransactionHash());
    } else {
      System.out.println(
          "<<<<<<<<<<<Output<<<<<<<Call to Store method failed, reason =" + sendResult.getError()
              .getData());
    }
  }


  /**
   * method description Call the retrieve method of the contract. 1，callUseProxy：Use the proxy class
   * generated by abi and bin to call the retrieve method of the contract. Result: Outputs the value
   * stored (in decimal) when the Store method was called. 2，callUseWeb3j：Use web3j to call the
   * retrieve method of the contract. Result: Outputs the stored decimal value (in hexadecimal) when
   * the Store method was called.
   *
   * @param
   * @return void
   * @date 2023/4/3
   */
  @Test
  public void callUseProxy() throws Exception {

    httpService.addHeader("apiToken", apiToken);

    Web3j web3jHttp = Web3j.build(httpService);

    // gasPrice is 0, gasLimit is obtained from the chain and multiplied by 10
    StaticGasProvider staticGasProvider = new StaticGasProvider(gasPrice, testEstimateGas());

    // Initialize the contract
    A contractA = A.load(
        contractAddress,
        web3jHttp,
        new RawTransactionManager(web3jHttp, credentials, attempts, sleepDuration),
        staticGasProvider
    );

    // Call the contract retrieve method
    BigInteger storeNum = contractA.retrieve().send();

    System.out.println(
        "<<<<<<<<<<<Output<<<<<<<Calling the Retrieve method succeeds, result =" + storeNum);

  }


  /**
   * method description Call the retrieve method of the contract. 1，callUseProxy：Use the proxy class
   * generated by abi and bin to call the retrieve method of the contract. Result: Outputs the value
   * stored (in decimal) when the Store method was called. 2，callUseWeb3j：Use web3j to call the
   * retrieve method of the contract. Result: Outputs the stored decimal value (in hexadecimal) when
   * the Store method was called.
   *
   * @param
   * @return void
   * @date 2023/4/3
   */
  @Test
  public void callUseWeb3j() throws IOException {

    httpService.addHeader("apiToken", apiToken);

    Web3j web3jHttp = Web3j.build(httpService);

    // Assemble call contract parameters
    org.web3j.abi.datatypes.Function function = new org.web3j.abi.datatypes.Function("retrieve",
        Arrays.<Type>asList(),
        Arrays.<TypeReference<?>>asList(new TypeReference<Uint256>() {
        }));

    // encryption
    String data = FunctionEncoder.encode(function);

    // Assembly Transaction
    org.web3j.protocol.core.methods.request.Transaction ethCallTransaction = Transaction
        .createFunctionCallTransaction(
            accountAddr,
            null,
            null,
            null,
            contractAddress,
            data);

    // Use web3j's ethCall to call the contract retrieve method
    EthCall callResult = web3jHttp.ethCall(ethCallTransaction, DefaultBlockParameterName.LATEST)
        .send();

    if (callResult.getError() == null) {
      String replace = callResult.getValue().replace("0x", "");
      System.out.println(
          "<<<<<<<<<<<Output<<<<<<<Call Retrieve method successfully, result (hexadecimal) ="
              + replace);
    } else {
      System.out.println(
          "<<<<<<<<<<<Output<<<<<<<Failed to call Retrieve method, reason =" + callResult.getError()
              .getData());
    }

  }


  /**
   * method description Get the event after calling the store method. Get the event generated when
   * the contract Store method is called, and the stored value (decimal) will be output
   *
   * @param
   * @return void
   * @date 2023/4/3
   */
  @Test
  public void getStoreEvent() throws IOException {

    // gasPrice is 0, gasLimit is obtained from the chain and multiplied by 10
    StaticGasProvider staticGasProvider = new StaticGasProvider(gasPrice, testEstimateGas());

    // The starting block number, for testing, starts from 15192232 because the current block number is relatively large.
    DefaultBlockParameterNumber startBlockNumber = new DefaultBlockParameterNumber(0);

    // End block number, LATEST represents the latest block number
    DefaultBlockParameterName latest = DefaultBlockParameterName.LATEST;

    // Connect to BN's websocket
    ws.connect();

    // Build web3j with websocket
    Web3j web3j = Web3j.build(ws);

    // Initialize the contract proxy class
    A contractA = A.load(contractAddress, web3j, credentials, staticGasProvider);

    // Call the storeEventFlowable of the contract proxy class
    Flowable<StoreEventResponse> storeEventResponseFlowable = contractA
        .storeEventFlowable(startBlockNumber, latest);

    // Analysis result
    storeEventResponseFlowable.subscribe(log -> {
      System.out.println(
          "<<<<<<<<<<<Output<<<<<<<Asynchronously obtain the event generated by calling the contract Store method successfully，sender="
              + log.sender + "，num=" + log.num);
    });

  }


  /**
   * method description Query the transaction result according to the transaction hash and return
   * the contract address
   *
   * @return java.lang.String
   * @date 2023/4/1
   */
  @Test
  public void getContractAddressByHash() throws IOException {

    httpService.addHeader("apiToken", apiToken);

    Web3j web3jHttp = Web3j.build(httpService);

    // hash is the hash output after executing the deployUseWeb3j method, please replace it manually
    String transactionHash = "0xbc1d5c6538559442204b5fc30524421bb6ebda11035409de9143ad203dfe0fe6";

    EthGetTransactionReceipt send = web3jHttp.ethGetTransactionReceipt(transactionHash).send();

    if (send.hasError()) {
      String message = send.getError().getMessage();
      int code = send.getError().getCode();
      System.out.println(
          "<<<<<<<<<<<Output<<<<<<<Failed to get contract address，code=" + code + ",reason："
              + message);
    } else {
      String contractAddress = send.getTransactionReceipt().get().getContractAddress();

      System.out.println(
          "<<<<<<<<<<<Output<<<<<<<Please configure the contract address to private String contractAddress");
      System.out.println("<<<<<<<<<<<Output<<<<<<<Contract address=" + contractAddress);
    }
  }


  /**
   * method description Query transaction results based on hash
   *
   * @param
   * @return void
   * @date 2023/4/3
   */
  @Test
  public void getResultByHash() throws IOException {

    httpService.addHeader("apiToken", apiToken);

    Web3j web3jHttp = Web3j.build(httpService);

    // hash is the hash output after executing the invokeUseWeb3j method, please replace it manually
    String hash = "0xc0f8de8c29126db0bf1837af749eb8a1380f7dcb36a368485f24ea5a87492ec1";

    EthGetTransactionReceipt sendResult = web3jHttp.ethGetTransactionReceipt(hash).send();

    TransactionReceipt result = sendResult.getResult();

    System.out.println("<<<<<<<<<<<Output<<<<<<<Query results based on hash=" + result);

  }


  /**
   * method description Obtain the signature data of the retrieve method of the calling contract
   *
   * @param
   * @return void
   * @date 2023/4/7
   */
  @Test
  public void getCallSignatureStrTest() {

    // Assemble call contract parameters
    org.web3j.abi.datatypes.Function function = new org.web3j.abi.datatypes.Function("retrieve",
        Arrays.<Type>asList(),
        Arrays.<TypeReference<?>>asList(new TypeReference<Uint256>() {
        }));

    // encryption
    String data = FunctionEncoder.encode(function);

    System.out.println("<<<<<<<<<<<Output<<<<<<<Get the call method signature data：\n"
        + "data:" + data + "\n"
        + "from:" + accountAddr + "\n"
        + "to:" + contractAddress);

  }


  /**
   * method description Get the deployment contract signature data
   *
   * @param
   * @return void
   * @date 2023/4/7
   */
  @Test
  public void getDeploySignatureStrTest() throws IOException {

    String deploySignatureStr = getDeploySignatureStr();

    System.out.println(
        "<<<<<<<<<<<Output<<<<<<<Deploy the signature data of the contract=" + deploySignatureStr);
  }


  /**
   * method description Get the signature data for calling the contract store method
   *
   * @param
   * @return void
   * @date 2023/4/7
   */
  @Test
  public void getStoreSignatureStrTest() throws IOException {

    // data stored on the chain,
    BigInteger num = new BigInteger("123456");

    String storeSignatureStr = getStoreSignatureStr(num);

    System.out.println(
        "<<<<<<<<<<<Output<<<<<<<Signature data for calling the contract store method="
            + storeSignatureStr);
  }


  /**
   * method description Get the signed data of the deployment contract
   *
   * @param
   * @return java.lang.String
   * @date 2023/4/1
   */
  private String getDeploySignatureStr() throws IOException {

    // 获取nonce
    BigInteger transactionCount = getNonce();

    // gasPrice is 0, gasLimit is obtained from the chain and multiplied by 10
    RawTransaction transaction = RawTransaction.createTransaction(
        transactionCount,
        gasPrice,
        testEstimateGas(),
        null,
        new BigInteger("0"),
        "608060405234801561001057600080fd5b506106b0806100206000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c80632e64cec1146100465780635353a2d8146100645780636057361d14610080575b600080fd5b61004e61009c565b60405161005b919061017a565b60405180910390f35b61007e60048036038101906100799190610204565b6100a6565b005b61009a6004803603810190610095919061027d565b610109565b005b6000600154905090565b600080816100b49190610510565b503373ffffffffffffffffffffffffffffffffffffffff167fbb65f02a08ca2759ab26ef9929bf648f890a58e115823859923e3a6d0c6dfca883836040516100fd929190610656565b60405180910390a25050565b806001819055503373ffffffffffffffffffffffffffffffffffffffff167fcc9d847ba10dcd14a97c82e34eddd0f93ea7a927fb7d6e00da2ca1b26c5823ae82604051610156919061017a565b60405180910390a250565b6000819050919050565b61017481610161565b82525050565b600060208201905061018f600083018461016b565b92915050565b600080fd5b600080fd5b600080fd5b600080fd5b600080fd5b60008083601f8401126101c4576101c361019f565b5b8235905067ffffffffffffffff8111156101e1576101e06101a4565b5b6020830191508360018202830111156101fd576101fc6101a9565b5b9250929050565b6000806020838503121561021b5761021a610195565b5b600083013567ffffffffffffffff8111156102395761023861019a565b5b610245858286016101ae565b92509250509250929050565b61025a81610161565b811461026557600080fd5b50565b60008135905061027781610251565b92915050565b60006020828403121561029357610292610195565b5b60006102a184828501610268565b91505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b600060028204905060018216806102f157607f821691505b602082108103610304576103036102aa565b5b50919050565b600081549050610319816102d9565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b60008190508160005260206000209050919050565b60008190508160005260206000209050919050565b60006020601f8301049050919050565b600082821b905092915050565b6000600883026103c67fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82610389565b6103d08683610389565b95508019841693508086168417925050509392505050565b6000819050919050565b600061040d61040861040384610161565b6103e8565b610161565b9050919050565b6000819050919050565b610427836103f2565b61043b61043382610414565b848454610396565b825550505050565b600090565b610450610443565b61045b81848461041e565b505050565b5b8181101561047f57610474600082610448565b600181019050610461565b5050565b601f8211156104c4576104958161034f565b61049e84610379565b810160208510156104ad578190505b6104c16104b985610379565b830182610460565b50505b505050565b600082821c905092915050565b60006104e7600019846008026104c9565b1980831691505092915050565b600061050083836104d6565b9150826002028217905092915050565b81810361051e5750506105f6565b6105278261030a565b67ffffffffffffffff8111156105405761053f610320565b5b61054a82546102d9565b610555828285610483565b6000601f8311600181146105845760008415610572578287015490505b61057c85826104f4565b8655506105ef565b601f19841661059287610364565b965061059d8661034f565b60005b828110156105c5578489015482556001820191506001850194506020810190506105a0565b868310156105e257848901546105de601f8916826104d6565b8355505b6001600288020188555050505b5050505050505b565b600082825260208201905092915050565b82818337600083830152505050565b6000601f19601f8301169050919050565b600061063583856105f8565b9350610642838584610609565b61064b83610618565b840190509392505050565b60006020820190508181036000830152610671818486610629565b9050939250505056fea2646970667358221220d04ace6b846f6ca6c71c12b81c63264e8191226193c651045596adc11af454dd64736f6c63430008120033",
        null,
        null
    );

    byte[] bytes = TransactionEncoder.signMessage(transaction, credentials);

    String signature = Numeric.toHexString(bytes);

    System.out.println("<<<<<<<<<<<Output<<<<<<<Deploy signed data=" + signature);

    return signature;
  }


  /**
   * method description Get the signature data for calling the Store method
   *
   * @param
   * @return java.lang.String
   * @date 2023/4/3
   */
  private String getStoreSignatureStr(BigInteger storeNum) throws IOException {

    // get nonce
    BigInteger transactionCount = getNonce();

    final org.web3j.abi.datatypes.Function function = new org.web3j.abi.datatypes.Function(
        "store",
        Arrays.<Type>asList(new Uint256(storeNum)),
        Collections.<TypeReference<?>>emptyList());

    String data = FunctionEncoder.encode(function);

    // gasPrice is 0, gasLimit is obtained from the chain and multiplied by 10
    RawTransaction transaction = RawTransaction.createTransaction(
        transactionCount,
        gasPrice,
        testEstimateGas(),
        contractAddress,
        new BigInteger("0"),
        data,
        null,
        null
    );

    byte[] bytes = TransactionEncoder.signMessage(transaction, credentials);

    String signature = Numeric.toHexString(bytes);

    System.out.println("<<<<<<<<<<<Output<<<<<<<Call the Store method, signed data=" + signature);

    return signature;
  }


  /**
   * method description Get the user's nonce
   *
   * @param
   * @return java.math.BigInteger
   * @date 2023/4/3
   */
  private BigInteger getNonce() throws IOException {

    httpService.addHeader("apiToken", apiToken);

    Web3j web3jHttp = Web3j.build(httpService);

    // request eth_getTransactionCount
    EthGetTransactionCount send = web3jHttp
        .ethGetTransactionCount(accountAddr, DefaultBlockParameterName.LATEST).send();

    // get nonce
    BigInteger transactionCount = send.getTransactionCount();

    return transactionCount;
  }


  /**
   * method description Estimate the amount of gas required for a transaction. For safety, multiply
   * the returned value by a factor of 10
   *
   * @param
   * @return void
   * @date 2023/4/4
   */
  private BigInteger testEstimateGas() throws IOException {

//    org.web3j.protocol.core.methods.request.Transaction  transaction = new Transaction(
//        accountAddr,
//        null,
//        null,
//        null,
//        null,
//        BigInteger.ZERO,
//        ""
//    );
//
//    EthEstimateGas send = web3jHttp.ethEstimateGas(transaction).send();
//
//    BigInteger amountUsed = send.getAmountUsed();
//
//    return amountUsed.multiply(BigInteger.TEN);
    return new BigInteger("5000000");
  }


}

